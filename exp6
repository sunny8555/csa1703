from search import Problem
import random
class VacuumProblem(Problem):
    def __init__(self):
        initial_state = [[1,1,1,0,0,0,0,0,0], 4]       
        goal_state = [ [[0,0,0,0,0,0,0,0,0], i] for i in range(0,9)]
        super().__init__(initial_state, goal_state)   
    def actions(self, state):
        loc = state[1]
        if state[0][loc] == 1:
            return ["SUCK"]
        elif loc == 0:
            return ["DOWN", "RIGHT"]
        elif loc == 3:
            return ["UP", "DOWN", "RIGHT"]
        elif loc == 6:
            return ["UP", "RIGHT"]
        elif loc == 1:
            return ["DOWN", "LEFT", "RIGHT"]
        elif loc == 4:
            return ["UP", "DOWN", "LEFT", "RIGHT"]
        elif loc == 7:
            return ["UP", "LEFT", "RIGHT"]
        elif loc == 2:
            return ["DOWN", "LEFT"]
        elif loc == 5:
            return ["UP", "DOWN", "LEFT"]
        elif loc == 8:
            return ["UP", "LEFT"]
        else:
            return ["FAILURE"]
    def result(self, p_state, action):
        world = list(p_state[0])
        loc = p_state[1]
        state = []
        state.append(world)
        state.append(loc)
        if action is "SUCK":
            state[0][state[1]] = 0
            return state
        elif action is "LEFT":
            state[1] -= 1
            return state
        elif action is "RIGHT":
            state[1] += 1
            return state
        elif action is "UP":
            state[1] -= 3
            return state
        
        elif action is "DOWN":
            state[1] += 3
            return state    
    def path_cost(self, cur_cost, state1, action, state2):
        if action is "SUCK":
            new_cost = abs(-2 * state2[0].count(1) -1)
            cost = cur_cost + new_cost
            return cost
        else:
            new_cost = abs(-2 * state1[0].count(1) -1)
            cost = cur_cost + new_cost
            return cost        
    def goal_test(self, state):
        for g in self.goal:
            if g == state:
                return True        
    def h(self, n):
        h_cost = 0
        min_dist = 10000000
        num_actions = 0
        dirty = 0
        pos = n.state[1]
        count = 0
        for s in n.state[0]:
            if s == 1:
                dirty += 1
                dist = abs(pos - count)
                if min_dist > dist:
                    min_dist = dist
            count += 1
        num_actions = min_dist + 1    
        h_cost = dirty + min_dist + num_actions
        return h_cost
